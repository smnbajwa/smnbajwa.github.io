<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LM9SX5RQS9"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-LM9SX5RQS9');
</script>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <title>Self-Balancing Robot</title>
</head>
<h1 align="center">Self-Balancing Robot using Arduino</h1>
    <body><div class="container">
      <table border=0 cellspacing=0 cellpadding=0 width=435><tr valign=top><td width=435>
        <h4 class="home"><a href="index.html">Home</a></h4>
        <p>Date added: 03 October 2022</p>     
        <p>Status: Ongoing</p>
        <b>Summary:</b>
        <p> This project was heavily inspired by <a href="http://www.brokking.net/yabr_main.html">YABR by Brokking</a>. I am using slightly different hardware and as a result I had to revise his code to get it work.</p>
        <p>My next step for this project is to program the ATMega328 directly using C rather than using Arduino IDE</p>
        <b>Issues encountered:</b>
        <ol>
        <li>Acrylic sheets were prone to vibration and noisy. It was hard to
           tighten the nuts on them even with washers. The vibrations would
           make the nuts loose. That's why wood is a better choice. It does
           not vibrate and nuts dig into it so they are secured.</li>
        
        <li>Initially I used a breadboard for the circuit. The robot would
          randomly stop and fall over. Turns out that the vibrations made the
          connection between the wire and breadboard intermittent. The
          microcontroller lost power and turned off.<br>
        That's why I decided to solder the components on a DOT PCB.</li>
        
        <li>The inspiration of the robot came from a YouTube I watched.
          I sourced some of same components but not all because I did not
          just want to copy someone else's design as is. As a result the 
          control program would not work as is and I did not have enough
          expertise in C++ to modify it.
        
        <p>I decided to write my own program for the control. I had to take 
        a detour and learn some C++ to be able to do that. It was a mistake 
        as there are no simple libraries I could just use. </p>
        
        <p>The gyro sensor calculates angle of tilt every 4ms. This angle is 
        used
        as error and fed into a PID loop which drives the motors a 
        certain amount to bring the robot back to equilibrium position.</p>
        
        <p>There are existing libraries to control the speed or acceleration of a 
        stepper motor. However, they don't work if I change the speed every 4ms.
        This is because these libraries have functions which call other functions
        in the Arduino library which take much longer time than 4ms.
        
        <p>Also, it is not just the programming knowledge that I needed.
          There are features of AVR microcontrollers that I was unaware of. </p>
        
        <p>I learned that it is possible to change bits on a specific register to 
        drive the motor one step. This is much faster than calling functions 
        provided by the library.</li></p>
        </ol>
        </td></tr></table>
        <h4>Pictures/Video:</h4>
            <div class="media"><figure class="rounded mx-auto d-block"><a href="./images/circuit1.jpg" target="_blank"><img src="./images/circuit1.jpg" alt="Circuit" height="315"></a> 
            <figcaption>Fig. 1 - Components soldered on protoboard <br>(1) Arduino Nano (2) MPU6050 (3) A4988 Stepper motor driver x2 <br>(4) DC-DC voltage converter (added later) (5) 100uF Capacitors x2</figcaption>
            </figure>
            <figure><a href="./images/chasis.jpg" target="_blank"><img src="./images/chasis.jpg" alt="Chasis" height="500"></a> 
                <figcaption>Fig. 2 - Chasis of the Robot
                </figcaption>
                </figure>
            <figure>
                <iframe width="560" height="315" src="https://www.youtube.com/embed/CptsSRe3XCs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>   
            <figcaption>Fig. 3 - Robot balancing itself</figcaption>
            </figure>
          </div>
        <h4>Code:</h4><pre><code>
            #include <Wire.h>                                            //Include the Wire.h library so we can communicate with the gyro
            int gyro_address = 0x68;                                     //MPU-6050 I2C address (0x68 or 0x69)
            int acc_calibration_value = -323;                            //Enter the accelerometer calibration value
            
            //Various settings
            float pid_p_gain = 15;                                       //Gain setting for the P-controller (15)
            float pid_i_gain = 1.5;                                      //Gain setting for the I-controller (1.5)
            float pid_d_gain = 30;                                       //Gain setting for the D-controller (30)
            float turning_speed = 30;                                    //Turning speed (20)
            float max_target_speed = 150;                                //Max target speed (100)
            
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //Declaring global variables
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            byte start, received_byte, low_bat;
            
            int left_motor, throttle_left_motor, throttle_counter_left_motor, throttle_left_motor_memory;
            int right_motor, throttle_right_motor, throttle_counter_right_motor, throttle_right_motor_memory;
            int battery_voltage;
            int receive_counter;
            int gyro_pitch_data_raw, gyro_yaw_data_raw, accelerometer_data_raw;
            
            long gyro_yaw_calibration_value, gyro_pitch_calibration_value;
            
            unsigned long loop_timer;
            
            float angle_gyro, angle_acc, angle, self_balance_pid_setpoint;
            float pid_error_temp, pid_i_mem, pid_setpoint, gyro_input, pid_output, pid_last_d_error;
            float pid_output_left, pid_output_right;
            
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //Setup basic functions
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            void setup(){
              Serial.begin(9600);                                                       //Start the serial port at 9600 kbps
              Wire.begin();                                                             //Start the I2C bus as master
              TWBR = 12;                                                                //Set the I2C clock speed to 400kHz
            
              //To create a variable pulse for controlling the stepper motors a timer is created that will execute a piece of code (subroutine) every 20us
              //This subroutine is called TIMER2_COMPA_vect
              TCCR2A = 0;                                                               //Make sure that the TCCR2A register is set to zero
              TCCR2B = 0;                                                               //Make sure that the TCCR2A register is set to zero
              TIMSK2 |= (1 << OCIE2A);                                                  //Set the interupt enable bit OCIE2A in the TIMSK2 register
              TCCR2B |= (1 << CS21);                                                    //Set the CS21 bit in the TCCRB register to set the prescaler to 8
              OCR2A = 39;                                                               //The compare register is set to 39 => 20us / (1s / (16.000.000MHz / 8)) - 1
              TCCR2A |= (1 << WGM21);                                                   //Set counter 2 to CTC (clear timer on compare) mode
              
              //By default the MPU-6050 sleeps. So we have to wake it up.
              Wire.beginTransmission(gyro_address);                                     //Start communication with the address found during search.
              Wire.write(0x6B);                                                         //We want to write to the PWR_MGMT_1 register (6B hex)
              Wire.write(0x00);                                                         //Set the register bits as 00000000 to activate the gyro
              Wire.endTransmission();                                                   //End the transmission with the gyro.
              //Set the full scale of the gyro to +/- 250 degrees per second
              Wire.beginTransmission(gyro_address);                                     //Start communication with the address found during search.
              Wire.write(0x1B);                                                         //We want to write to the GYRO_CONFIG register (1B hex)
              Wire.write(0x00);                                                         //Set the register bits as 00000000 (250dps full scale)
              Wire.endTransmission();                                                   //End the transmission with the gyro
              //Set the full scale of the accelerometer to +/- 4g.
              Wire.beginTransmission(gyro_address);                                     //Start communication with the address found during search.
              Wire.write(0x1C);                                                         //We want to write to the ACCEL_CONFIG register (1A hex)
              Wire.write(0x08);                                                         //Set the register bits as 00001000 (+/- 4g full scale range)
              Wire.endTransmission();                                                   //End the transmission with the gyro
              //Set some filtering to improve the raw data.
              Wire.beginTransmission(gyro_address);                                     //Start communication with the address found during search
              Wire.write(0x1A);                                                         //We want to write to the CONFIG register (1A hex)
              Wire.write(0x04);                                                         //Set the register bits as 00000011 (Set Digital Low Pass Filter to ~43Hz)
              Wire.endTransmission();                                                   //End the transmission with the gyro 
            
              pinMode(6, OUTPUT);                                                       //Configure digital poort 2 as output
              pinMode(3, OUTPUT);                                                       //Configure digital poort 3 as output
              pinMode(4, OUTPUT);                                                       //Configure digital poort 4 as output
              pinMode(5, OUTPUT);                                                       //Configure digital poort 5 as output
              pinMode(13, OUTPUT);                                                      //Configure digital poort 6 as output
            
              for(receive_counter = 0; receive_counter < 500; receive_counter++){       //Create 500 loops
                if(receive_counter % 15 == 0)digitalWrite(13, !digitalRead(13));        //Change the state of the LED every 15 loops to make the LED blink fast
                Wire.beginTransmission(gyro_address);                                   //Start communication with the gyro
                Wire.write(0x43);                                                       //Start reading the Who_am_I register 75h
                Wire.endTransmission();                                                 //End the transmission
                Wire.requestFrom(gyro_address, 4);                                      //Request 2 bytes from the gyro
                gyro_yaw_calibration_value += Wire.read()<<8|Wire.read();               //Combine the two bytes to make one integer
                gyro_pitch_calibration_value += Wire.read()<<8|Wire.read();             //Combine the two bytes to make one integer
                delayMicroseconds(3700);                                                //Wait for 3700 microseconds to simulate the main program loop time
              }
              gyro_pitch_calibration_value /= 500;                                      //Divide the total value by 500 to get the avarage gyro offset
              gyro_yaw_calibration_value /= 500;                                        //Divide the total value by 500 to get the avarage gyro offset
            
              loop_timer = micros() + 4000;                                             //Set the loop_timer variable at the next end loop time
            
            }
            
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //Main program loop
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            void loop(){
              if(Serial.available()){                                                   //If there is serial data available
                received_byte = Serial.read();                                          //Load the received serial data in the received_byte variable
                receive_counter = 0;                                                    //Reset the receive_counter variable
              }
              if(receive_counter <= 25)receive_counter ++;                              //The received byte will be valid for 25 program loops (100 milliseconds)
              else received_byte = 0x00;                                                //After 100 milliseconds the received byte is deleted
              
            
              ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
              //Angle calculations
              ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
              Wire.beginTransmission(gyro_address);                                     //Start communication with the gyro
              Wire.write(0x3B);                                                         //Start reading at register 3F
              Wire.endTransmission();                                                   //End the transmission
              Wire.requestFrom(gyro_address, 2);                                        //Request 2 bytes from the gyro
              accelerometer_data_raw = Wire.read()<<8|Wire.read();                      //Combine the two bytes to make one integer
              accelerometer_data_raw += acc_calibration_value;                          //Add the accelerometer calibration value
              if(accelerometer_data_raw > 8200)accelerometer_data_raw = 8200;           //Prevent division by zero by limiting the acc data to +/-8200;
              if(accelerometer_data_raw < -8200)accelerometer_data_raw = -8200;         //Prevent division by zero by limiting the acc data to +/-8200;
            
              angle_acc = asin((float)accelerometer_data_raw/8200.0)* 57.296;           //Calculate the current angle according to the accelerometer
            
              if(start == 0 && angle_acc > -0.5&& angle_acc < 0.5){                     //If the accelerometer angle is almost 0
                angle_gyro = angle_acc;                                                 //Load the accelerometer angle in the angle_gyro variable
                start = 1;                                                              //Set the start variable to start the PID controller
              }
              //angle_gyro = angle_acc;
              Wire.beginTransmission(gyro_address);                                     //Start communication with the gyro
              Wire.write(0x43);                                                         //Start reading at register 43
              Wire.endTransmission();                                                   //End the transmission
              Wire.requestFrom(gyro_address, 4);                                        //Request 4 bytes from the gyro
              gyro_yaw_data_raw = Wire.read()<<8|Wire.read();                           //Combine the two bytes to make one integer
              gyro_pitch_data_raw = Wire.read()<<8|Wire.read();                         //Combine the two bytes to make one integer
              
              gyro_pitch_data_raw -= gyro_pitch_calibration_value;                      //Add the gyro calibration value
              angle_gyro += gyro_pitch_data_raw * 0.000031;                             //Calculate the traveled during this loop angle and add this to the angle_gyro variable
              
              ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
              //MPU-6050 offset compensation
              ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
              //Not every gyro is mounted 100% level with the axis of the robot. This can be cause by misalignments during manufacturing of the breakout board. 
              //As a result the robot will not rotate at the exact same spot and start to make larger and larger circles.
              //To compensate for this behavior a VERY SMALL angle compensation is needed when the robot is rotating.
              //Try 0.0000003 or -0.0000003 first to see if there is any improvement.
            
              gyro_yaw_data_raw -= gyro_yaw_calibration_value;                          //Add the gyro calibration value
              //Uncomment the following line to make the compensation active
              //angle_gyro -= gyro_yaw_data_raw * 0.0000003;                            //Compensate the gyro offset when the robot is rotating
            
              angle_gyro = angle_gyro * 0.9996 + angle_acc * 0.0004;                    //Correct the drift of the gyro angle with the accelerometer angle
              //Serial.println(angle_gyro);
              ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
              //PID controller calculations
              ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
              //The balancing robot is angle driven. First the difference between the desired angel (setpoint) and actual angle (process value)
              //is calculated. The self_balance_pid_setpoint variable is automatically changed to make sure that the robot stays balanced all the time.
              //The (pid_setpoint - pid_output * 0.015) part functions as a brake function.
              pid_error_temp = angle_gyro - self_balance_pid_setpoint - pid_setpoint;
              if(pid_output > 10 || pid_output < -10)pid_error_temp += pid_output * 0.015 ;
            
              pid_i_mem += pid_i_gain * pid_error_temp;                                 //Calculate the I-controller value and add it to the pid_i_mem variable
              if(pid_i_mem > 400)pid_i_mem = 400;                                       //Limit the I-controller to the maximum controller output
              else if(pid_i_mem < -400)pid_i_mem = -400;
              //Calculate the PID output value
              pid_output = pid_p_gain * pid_error_temp + pid_i_mem + pid_d_gain * (pid_error_temp - pid_last_d_error);
              if(pid_output > 400)pid_output = 400;                                     //Limit the PI-controller to the maximum controller output
              else if(pid_output < -400)pid_output = -400;
            
              pid_last_d_error = pid_error_temp;                                        //Store the error for the next loop
            
              if(pid_output < 5 && pid_output > -5)pid_output = 0;                      //Create a dead-band to stop the motors when the robot is balanced
            
              if(angle_gyro > 30 || angle_gyro < -30 || start == 0){    //If the robot tips over or the start variable is zero or the battery is empty
                pid_output = 0;                                                         //Set the PID controller output to 0 so the motors stop moving
                pid_i_mem = 0;                                                          //Reset the I-controller memory
                start = 0;                                                              //Set the start variable to 0
                self_balance_pid_setpoint = 0;                                          //Reset the self_balance_pid_setpoint variable
              }
            
              ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
              //Control calculations
              ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
              pid_output_left = pid_output;                                             //Copy the controller output to the pid_output_left variable for the left motor
              pid_output_right = pid_output;                                            //Copy the controller output to the pid_output_right variable for the right motor
            
              //The self balancing point is adjusted when there is not forward or backwards movement from the transmitter. This way the robot will always find it's balancing point
              if(pid_setpoint == 0){                                                    //If the setpoint is zero degrees
                if(pid_output < 0)self_balance_pid_setpoint += 0.0015;                  //Increase the self_balance_pid_setpoint if the robot is still moving forewards
                if(pid_output > 0)self_balance_pid_setpoint -= 0.0015;                  //Decrease the self_balance_pid_setpoint if the robot is still moving backwards
              }
            
              ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
              //Motor pulse calculations
              ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
              //To compensate for the non-linear behaviour of the stepper motors the folowing calculations are needed to get a linear speed behaviour.
              if(pid_output_left > 0)pid_output_left = 405 - (1/(pid_output_left + 9)) * 5500;
              else if(pid_output_left < 0)pid_output_left = -405 - (1/(pid_output_left - 9)) * 5500;
            
              if(pid_output_right > 0)pid_output_right = 405 - (1/(pid_output_right + 9)) * 5500;
              else if(pid_output_right < 0)pid_output_right = -405 - (1/(pid_output_right - 9)) * 5500;
            
              //Calculate the needed pulse time for the left and right stepper motor controllers
              if(pid_output_left > 0)left_motor = 400 - pid_output_left;
              else if(pid_output_left < 0)left_motor = -400 - pid_output_left;
              else left_motor = 0;
            
              if(pid_output_right > 0)right_motor = 400 - pid_output_right;
              else if(pid_output_right < 0)right_motor = -400 - pid_output_right;
              else right_motor = 0;
            
              //Copy the pulse time to the throttle variables so the interrupt subroutine can use them
              throttle_left_motor = left_motor;
              throttle_right_motor = right_motor;
            
              ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
              //Loop time timer
              ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
              //The angle calculations are tuned for a loop time of 4 milliseconds. To make sure every loop is exactly 4 milliseconds a wait loop
              //is created by setting the loop_timer variable to +4000 microseconds every loop.
              while(loop_timer > micros());
              loop_timer += 4000;
            }
            
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //Interrupt routine  TIMER2_COMPA_vect
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ISR(TIMER2_COMPA_vect){
              //Left motor pulse calculations
              throttle_counter_left_motor ++;                                           //Increase the throttle_counter_left_motor variable by 1 every time this routine is executed
              if(throttle_counter_left_motor > throttle_left_motor_memory){             //If the number of loops is larger then the throttle_left_motor_memory variable
                throttle_counter_left_motor = 0;                                        //Reset the throttle_counter_left_motor variable
                throttle_left_motor_memory = throttle_left_motor;                       //Load the next throttle_left_motor variable
                if(throttle_left_motor_memory < 0){                                     //If the throttle_left_motor_memory is negative
                  PORTD &= 0b10111111;                                                  //Set output 6 low to reverse the direction of the stepper controller
                  throttle_left_motor_memory *= -1;                                     //Invert the throttle_left_motor_memory variable
                }
                else PORTD |= 0b01000000;                                               //Set output 6 high for a forward direction of the stepper motor
              }
              else if(throttle_counter_left_motor == 1)PORTD |= 0b00001000;             //Set output 3 high to create a pulse for the stepper controller
              else if(throttle_counter_left_motor == 2)PORTD &= 0b11110111;             //Set output 3 low because the pulse only has to last for 20us 
            
            
            
              throttle_counter_right_motor ++;                                           //Increase the throttle_counter_left_motor variable by 1 every time this routine is executed
              if(throttle_counter_right_motor > throttle_right_motor_memory){             //If the number of loops is larger then the throttle_left_motor_memory variable
                throttle_counter_right_motor = 0;                                        //Reset the throttle_counter_left_motor variable
                throttle_right_motor_memory = throttle_right_motor;                       //Load the next throttle_left_motor variable
                if(throttle_right_motor_memory < 0){                                     //If the throttle_left_motor_memory is negative
                  PORTD |= 0b00010000;
                                                                    //Set output 6 low to reverse the direction of the stepper controller
                  throttle_right_motor_memory *= -1;                                     //Invert the throttle_left_motor_memory variable
                }
                else PORTD &= 0b11101111;                                              //Set output 6 high for a forward direction of the stepper motor
              }
              else if(throttle_counter_right_motor == 1)PORTD |= 0b00100000;             //Set output 3 high to create a pulse for the stepper controller
              else if(throttle_counter_right_motor == 2)PORTD &= 0b11011111;             //Set output 3 low because the pulse only has to last for 20us 
            }</code></pre>


    </div>
</body>
</html>